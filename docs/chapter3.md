## 3.Bidirectional Payment Channels
## 3. 双向支付通道

Micropayment channels permit a simple defdeerral of a transaction state to be broadcast at a later time. The contracts are enforced by creating a responsibility for one party to broadcast transactions before or after certain dates. If the blockchain is a decentralized timestamping system, it is possible to use clocks as a component of decentralized consensus[5] to determine data validity, as well as present states as a method to order events[6].

> 微支付通道允许将一笔交易简单的延迟到以后广播。这些合约的执行方式是：让一方必须在特定日期之前或之后广播交易。如果区块链是一个去中心化的时间戳系统，那么可以使用时间戳作为去中心化共识的一个部分来确定数据的有效性，这相当于解决了当前状态的时序同步问题[6]。

By creating timeframes where certain states can be broadcast and later invalidated, it is possible to create complex contracts using bitcoin transaction scripts. There has been prior work for Hub-and-Spoke Micro- payment Channels[7][8][9] (and trusted payment channel networks[10][11]) looking at building a hub-and-spoke network today. However, Lightning Network’s bidirectional micropayment channel requires the malleability soft- fork described in Appendix A to enable near-infinite scalability while miti- gating risks of intermediate node default.

> 当前的交易状态下，这些交易可以被立即广播，或等待失效，通过为这个特定状态创建时间快照，就能利用比特币的交易脚本构建复杂的智能合约。此前，中心辐射型的微支付通道[7][8][9](以及可信支付通道[10][11])已经考虑了如何在今天构建一个中心辐射性微支付通道网络。但是，闪电网络的双向微支付通道需要比特币系统采取软分叉先解决附录中所描述的交易延展性问题，才能实现近乎无限的可扩展性，同时也能控制中间节点的出错风险。

By chaining together multiple micropayment channels, it is possible to create a network of transaction paths. Paths can be routed using a BGP- like system, and the sender may designate a particular path to the recipient. The output scripts are encumbered by a hash, which is generated by the recipient. By disclosing the input to that hash, the recipient’s counterparty will be able to pull funds along the route.

> 通过将多个微支付通道链接在一起，就有可能创建一个交易路径网络。路径可以使用类似BGP的协议进行路由，发送方可以指定特定的路径发送交易给接收方。输出脚本由接收方生成的散列来验证。通过提供散列的原像，接收方的交易对手就能够沿着这条路径传递资金。

### 3.1 The Problem of Blame in Channel Creation
### 3.1 通道创建中的责任问题

In order to participate in this payment network, one must create a micro- payment channel with another participant on this network.

> 为了参与到这个支付网络中来，一个人必须与这个网络上的另一个参与者创建一个微支付通道。

#### 3.1.1 Creating an Unsigned Funding Transaction
#### 3.1.1 创建一个未签署的保证金交易

An initial channel Funding Transaction is created whereby one or both chan- nel counterparties fund the inputs of this transaction. Both parties create the inputs and outputs for this transaction but do not sign the transaction.

> 最初的通道保证金交易需要交易的一方或交易双方为该交易的输入提供资金。双方参与创建这笔交易的输入和输出，但是先不对交易签名。

The output for this Funding Transaction is a single 2-of-2 multisigna-
ture script with both participants in this channel, henceforth named Alice and Bob. Both participants do not exchange signatures for the Funding Transaction until they have created spends from this 2-of-2 output refund- ing the original amount back to its respective funders. The purpose of not signing the transaction allows for one to spend from a transaction which does not yet exist. If Alice and Bob exchange the signatures from the Fund- ing Transaction without being able to broadcast spends from the Funding Transaction, the funds may be locked up forever if Alice and Bob do not cooperate (or other coin loss may occur through hostage scenarios whereby one pays for the cooperation from the counterparty).

> 这笔交易的输出是一个2/2多重签名地址，需要这个通道的双方参与者都同意才能花费这笔输出。我们按照惯例将通道两端的参与者命名为Alice和Bob。此时双方还不会为保证金交易交换签名，他们要先创建两笔花费，能够从保证金交易中将原始金额返还双方。不签署交易的目的是允许人们消费一个还不存在的交易。如果Alice和Bob在交换其签名之前广播保证金交易，此时一方不合作的话，这笔钱就可能被永久锁定(或者由一方承担了合作失败的损失)。

Alice and Bob both exchange inputs to fund the Funding Transaction(to know which inputs are used to determine the total value of the channel), and exchange one key to use to sign with later. This key is used for the 2-of-2 output for the Funding Transaction; both signatures are needed to spend from the Funding Transaction, in other words, both Alice and Bob need to agree to spend from the Funding Transaction.

> Alice和Bob互相交换保证金交易的输入(为了确定哪些输入用于确定通道的总容量)，然后交换一个密钥以供以后签名使用。这个密钥用于消费2/2保证金交易的输出，换句话说，如果要花费这笔保证金，需要Alice和Bob双方都同意。

#### 3.1.2 Spending from an Unsigned Transaction
#### 3.1.2 消费一笔未签名的交易

The Lightning Network uses a SIGHASH NOINPUT  transaction  to  spend from this 2-of-2 Funding Transaction output, as it is necessary to spend from a transaction for which the signatures are not yet exchanged. SIGHASH NOINPUT, implemented using a soft-fork, ensures transactions can be spent from before it is signed by all parties, as transactions would need to be signed to get a transaction ID without new sighash flags. Without SIGHASH NOINPUT, Bitcoin transactions cannot be spent from before they may be broadcast —it’s as if one could not draft a contract without paying the other party first. SIGHASH NOINPUT resolves this problem. See Appendix A for more information and implementation.

> 闪电网络使用 SIGHASH NOINPUT类型的交易来花费2/2保证金交易的输出，因为必须要构建一笔交易用于花费尚未交换签名的交易输出。SIGHASH NOINPUT将使用软分叉实现，它确保了交易可以在双方签署之前就能构造花费的交易，如果没有这个操作符的话，那交易就必须通过签署才能构造交易ID，那样就不能在广播这笔交易之前先来构造消费它的交易--这就好像一个人不先付款给另一方就不能起草合同一样。SIGHASH NOINPUT解决了这个问题，有关这方面更多信息和实现，亲参考附录A。

Without SIGHASH NOINPUT, it is not possible to generate a spend from a transaction without exchanging signatures, since spending the Fund- ing Transaction requires a transaction ID as part of the signature in the child’s input. A component of the Transaction ID is the parent’s (Funding Transaction’s) signature, so both parties need to exchange their signatures of the parent transaction before the child can be spent. Since one or both par- ties must know the parent’s signatures to spend from it, that means one or both parties are able to broadcast the parent (Funding Transaction) before the child even exists. SIGHASH NOINPUT gets around this by permitting the child to spend without signing the input. With SIGHASH NOINPUT, the order of operations are to:

> 如果没有SIGHASH NOINPUT，就无法在不交换签名的情况下生成花费它的交易，因为要花费保证金交易的输出，就需要交易ID作为花费交易输入的一部分。交易ID的一个组成部分是它的父交易方(即保证金交易)的签名，因此双方需要在创建子交易之前交换父交易的签名。由于一方或双方都需要夫交易的签名才能花费它，这就意味着一方或双方都能在子交易存在之前就能广播父交易(保证金交易)。SIGHASH NOINPUT允许子交易在不签署交易输入的情况下花费它，从而解决了这个问题。使用SIGHASH NOINPUT，操作顺序为：

1.Create the parent (Funding Transaction)

2.Create the children (Commitment Transactions and all spends from the commitment transactions)

3.Sign the children

4.Exchange the signatures for the children

5.Sign the parent

6.Exchange the signatures for the parent

7.Broadcast the parent on the blockchain

> 1.创建父交易(保证金交易)

> 2.创建子交易(承诺交易以及所有相关的承诺交易的花费)

> 3.为子交易签名

> 4.双方交换子交易的签名

> 5.为父交易签名

> 6.双方交换父交易的签名

> 7.在区块链上广播父交易

One is not able to broadcast the parent (Step 7) until Step 6 is com- plete. Both parties have not given their signature to spend from the Funding Transaction until step 6. Further, if one party fails during Step 6, the parent can either be spent to become the parent transaction or the inputs to the parent transaction can be double-spent (so that this entire transaction path is invalidated).

> 在第6步完成之前，不能广播父交易(步骤7)。在第6步之前，双方都没有签名同意花费保证金交易。此外，如果在第6步中，有一方作弊，即父交易被花费了，或者父交易的输入被双重支付，整个交易路径就都被认为是无效的。

#### 3.1.3 Commitment  Transactions:  Unenforcible Construction
#### 3.1.3 承诺交易: 不能强制履行

After the unsigned (and unbroadcasted) Funding Transaction has been cre- ated, both parties sign and exchange an initial Commitment Transaction. These Commitment Transactions spends from the 2-of-2 output of the Fund- ing Transaction (parent). However, only the Funding Transaction is broad- cast on the blockchain.

> 当还没有签名(且没有广播)的保证金交易创建完成之后，双方将签署并交换初始承诺交易。这些承诺交易花费的是2/2保证金交易的输出。值得注意的是，只有保证金交易才会广播上链。

Since the Funding Transaction has already entered into the blockchain, and the output is a 2-of-2 multisignature transaction which requires the agreement of both parties to spend from, Commitment Trans- actions are used to express the present balance. If only one 2-of-2 signed Commitment Transaction is exchanged between both parties, then both parties will be sure that they are able to get their money back after the Funding Transaction enters the blockchain. Both parties do not broadcast the Commitment Transactions onto the blockchain until they want to close out the current balance in the channel. They do so by broadcasting the present Commitment Transaction.

> 由于保证金交易已经广播入链，并且输出是一个2/2多重签名交易，这需要双方均同意才能花费，因此可以采用承诺交易来确认当前状态下双方的余额。如果双方之间只交换一笔2/2签名的承诺交易，而通过这笔交易，双方能确保在保证金交易广播入链后仍然能够取回资金。那么双方就不需要将承诺交易广播入链，除非他们希望关闭通道并结算余额。也只有这时候才需要广播承诺交易。

Commitment Transactions pay out the respective current balances to each party. A naive (broken) implementation would construct an unbroad- casted transaction whereby there is a 2-of-2 spend from a single transaction which have two outputs that return all current balances to both channel counterparties. This will return all funds to the original party when creat- ing an initial Commitment Transaction.

> 承诺交易会向每一方支付各自的流动余额。一个简单(不完整)的方法就是构建一笔交易，该交易花费2/2多重签名保证金交易的输入，有两个输出，就是将当前通道的余额返回给通道双方。通过创建这笔初始承诺交易，将会把通道资金的原始余额返回给双方。

![Figure1](figures/figure1.png?raw=true "Figure1")

Figure 1: A naive broken funding transaction is described in this diagram. The Funding Transaction (F), designated in green, is broadcast on the blockchain after all other trans- actions are signed. All other transactions spending from the funding transactions are not yet broadcast, in case the counterparties wish to update their balance. Only the Funding Transaction is broadcast on the blockchain at this time.

> 图一：图1描述了一个简单的分配保证金交易的方法。绿色的部分代表保证金交易(F)，当其他交易都签署之后才在区块链上广播，以防交易对手更新他们的通道余额。此场景中只有保证金交易才会被广播。

For instance, if Alice and Bob agree to create a Funding Transac- tion with a single 2-of-2 output worth 1.0 BTC (with 0.5 BTC contribution from each), they create a Commitment Transaction where there are two 0.5 BTC outputs for Alice and Bob. The Commitment Transactions are signed first and keys are exchanged so either is able to broadcast the Commitment Transaction at any time contingent upon the Funding Transaction enter- ing into the blockchain. At this point, the Funding Transaction signatures can safely be exchanged, as either party is able to redeem their funds by broadcasting the Commitment Transaction.

> 例如，如果Alice和Bob同意创建一笔包含1.0BTC(每一方存入0.5BTC)的2/2多重签名保证金交易，他们就需要创建一笔承诺交易，保证返还给Alice和Bob各自0.5BTC。双方首先对这笔承诺交易交换签名，这样在保证金交易广播入链后，任何一方都可以在任何时候广播这笔承诺交易。此时，可以放心的签署保证金交易，因为任何一方都可以通过广播承诺交易来赎回资金。

This construction breaks, however, when one wishes to update the present balance. In order to update the balance, they must update their Commitment Transaction output values (the Funding Transaction has al- ready entered into the blockchain and cannot be changed).

> 然而，当一方想要改变其当前通道内的余额时，这种结构就被打破了。为了更新余额，他们就必须更新他们的承诺交易的输出值(而保证金交易已经广播入链，不能更改了)。

When both parties agree to a new Commitment Transaction and ex- change signatures for the new Commitment Transaction, either Commit- ment Transactions can be broadcast. As the output from the Funding Transaction can only be redeemed once, only one of those transactions will be valid. For instance, if Alice and Bob agree that the balance of the channel
is now 0.4 to Alice and 0.6 to Bob, and a new Commitment Transaction is created to reflect that, either Commitment Transaction can be broadcast. In effect, one would be unable to restrict which Commitment Transaction is broadcast, since both parties have signed and exchanged the signatures for either balance to be broadcast.

> 当双方都同意新的承诺交易并为其交换签名的时候，任一提交的交易都可以被广播。由于保证金交易的输出只能花费一次，因此这些交易中只有一个是有效的。例如，如果Alice和Bob同意当前支付通道的余额分配是Alice拥有0.4BTC，Bob拥有0.6BTC，就需要创建一笔新的承诺交易来反映当前情况。此时之前的承诺交易也有可能被广播。实际上，当前无法限制广播哪个承诺交易，因为双方都已经交换的签名，任何一种余额分配的承诺交易都是可以广播的。


![Figure2](figures/figure2.png?raw=true "Figure2")

Figure 2: Either of the Commitment Transactions can be broadcast any any time by either party, only one will successfully spend from the single Funding Transaction. This cannot work because one party will not want to broadcast the most recent transaction.

> 图2：任何一方都可以在任何时间广播任何一笔承诺交易，当然，只有一笔是最终有效的。因为可能有一方并不希望广播最近的交易，却又无法限制这种情况，所以此方案存在缺陷。

Since either party may broadcast the Commitment Transaction at any time, the result would be after the new Commitment Transaction is gener- ated, the one who receives less funds has significant incentive to broadcast the transaction which has greater values for themselves in the Commitment Transaction outputs. As a result, the channel would be immediately closed and funds stolen. Therefore, one cannot create payment channels under this model.

> 由于任何一方都可以再任何时间广播承诺交易，那么在生成新的承诺交易后，持有较少资金的一方有显著的动机广播对自身输出金额更大的承诺交易。结果，该通道将立即关闭，资金将被窃取，因此，这种模式是无法安全的建立支付通道的。


#### 3.1.4 Commitment Transactions: Ascribing Blame
#### 3.1.4 承诺交易：归咎责任

Since any signed Commitment Transaction may be broadcast on the blockchain,  and only one can be successfully broadcast,  it is necessary   to prevent old Commitment Transactions from being broadcast.   It is   not possible to revoke tens of thousands of transactions in Bitcoin, so an alternate method is necessary. Instead of active revocation enforced by the blockchain, it’s necessary to construct the channel itself in similar manner to a Fidelity Bond, whereby both parties make commitments, and violations of these commitments are enforced by penalties. If one party violates their agreement, then they will lose all the money in the channel.

> 由于任何已签署的承诺交易都可以在区块链上广播，并且只能成功广播其中一笔交易，因此有必要防止旧的承诺交易被广播。但同时撤销数万笔比特币交易时不可能的，因此有必要采用另一种方法。与区块链强制执行的主动撤销不同，应该以类似于忠诚契约的方式来构造通道本身，双方据此作出承诺，当违反这些承诺时将会受到惩罚。如果一方违反了协议，他将失去通道中所有的资金。

For this payment channel, the contract terms are that both parties commit to broadcasting only the most recent transaction. Any broadcast of older transactions will cause a violation of the contract, and all funds are given to the other party as a penalty.

> 这种支付通道遵循这样的合同条款：双方承诺只广播最近的交易。任何旧交易的广播都将违反合同，所有的资金都将作为罚款给予另一方。

This can only be enforced if one is able to ascribe blame for broad- casting an old transaction. In order to do so, one must be able to uniquely identify who broadcast an older transaction. This can be done if each coun- terparty has a uniquely identifiable Commitment Transaction. Both parties must sign the inputs to the Commitment Transaction which the other party is responsible for broadcasting. Since one has a version of the Commitment Transaction that is signed by the other party, one can only broadcast one’s own version of the Commitment Transaction.

> 只有当一方可以对广播旧交易的另一方施以惩罚时，这一机制才能生效。为了做到这一点，必须能唯一的标识谁广播了较早的承诺交易。这需要每一方都有一笔唯一并可标识的承诺交易。双方必须签署对方负责广播的承诺交易的输入。如果一方拥有对方签署的承诺交易，他就可以放心广播自己所创建的承诺交易。

For the Lightning Network, all spends from the Funding Transaction output, Commitment Transactions, have two half-signed transactions. One Commitment Transaction in which Alice signs and gives to Bob (C1b), and another which Bob signs and gives to Alice (C1a). These two Commitment Transactions spend from the same output (Funding Transaction), and have different contents; only one can be broadcast on the blockchain, as both pairs of Commitment Transactions spend from the same Funding Transac- tion. Either party may broadcast their received Commitment Transaction by signing their version and including the counterparty’s signature. For ex- ample, Bob can broadcast Commitment C1b, since he has already received the signature for C1b from Alice —he includes Alice’s signature and signs C1b himself. The transaction will be a valid spend from the Funding Trans- action’s 2-of-2 output requiring both Alice and Bob’s signature.

> 对于闪电网络，所有的来自于保证金交易的输出的花费，即承诺交易们，都只有一半签名。其中 Alice对一笔承诺交易签名并发给Bob(C1b)，Bob对另一笔承诺交易并发给Alice(C1a)。这两笔承诺交易的输入来自于同一笔(保证金)交易，但是内容不同；这两笔交易只有一笔可以在区块链上广播。任何一方都可以收到包含对方签名的承诺交易，然后加上自己的签名进行广播。例如，Bob可以广播承诺交易C1b，因为他已经从Alice那里收到了C1b的签名--他只需要再对C1b自己签署一遍就可以了。这笔交易将是保证金交易2/2输出的有效花费，因为同时包含了Alice和Bob的签名。

![Figure3](figures/figure3.png?raw=true "Figure3")

Figure 3: Purple boxes are unbroadcasted transactions which only Alice can broadcast. Blue boxes are unbroadcasted transaction which only Bob can broadcast. Alice can only broadcast Commitment 1a, Bob can only broadcast Commitment 1b. Only one Commit- ment Transaction can be spent from the Funding Transaction output. Blame is ascribed, but either one can still be spent with no penalty.

> 图3：紫色方框是没有广播的交易，只有Alice可以广播。同理，蓝色方框也是没有广播的交易，只有Bob才能广播。Alice只能广播承诺交易1a，Bob只能广播承诺交易1b。消费保证金交易的输出中只有一笔承诺交易可以成功花费。在责任约束下，只有一方可以毫无代价的花费掉资金。

However, even with this construction, one has only merely allocated blame. It is not yet possible to enforce this contract on the Bitcoin blockchain. Bob still trusts Alice not to broadcast an old Commitment Transaction. At this time, he is only able to prove that Alice has done so via a half-signed transaction proof.

> 然而，即使有了这样的机制，也只是责任上的约束。目前尚不可能在比特币区块链上执行该合约。Bob仍需要信任Alice不会广播旧的承诺交易。在这个例子中，他只能通过一笔完成一半签名的交易来信任Alice。

### 3.2 Creating a Channel with Contract Revocation

### 3.2 创建能够撤销合约的通道

To be able to actually enforce the terms of the contract, it’s necessary to construct a Commitment Transaction (along with its spends) where one is able to revoke a transaction. This revocation is achievable by using data about when a transaction enters into a blockchain and using the maturity of the transaction to determine validation paths.

> 为了能够确实的执行合约，有必要构建这样一笔承诺交易：交易本身以及这笔交易的输出花费，都是可撤销的。可以通过控制这笔交易何时广播入链，并使用交易的到期时间来确定验证路径，从而实现这种撤销。

### 3.3 Sequence Number Maturity

### 3.3 序列数到期时间

Mark Freidenbach has proposed that Sequence Numbers can be en- forcible via a relative block maturity of the parent transaction via a soft-fork[12].  This would allow some basic ability to ensure some form   of relative block confirmation time lock on the spending script. In addition, an additional opcode, OP CHECKSEQUENCEVERIFY[13] (a.k.a.  OP RELATIVECHECKLOCKTIMEVERIFY)[14], would permit further abilities, including allowing a stop-gap solution before a more permanent solution for resolving transaction malleability. A future version of this paper will include proposed solutions.

> Mark Freidenbach提出，通过软分叉[12]，可以设置一个序列数字，只有父交易的区块确认数达到序列数的要求后，交易才能生效。这将允许支出脚本实现一些基本的功能，可以在区块达到一定确认数目之后才会执行。另外，还可以增加一个操作码，OP_CHECKSEQUENCEVERIFY[13] (或者命名为OP_RELATIVECHECKLOCKTIMEVERIFY)[14]，它将允许更多的功能，包括在完全解决交易延展性问题的方案实行之前先实行一个临时解决方案。本文将来会持续更新建议的解决方案。


To summarize, Bitcoin was released with a sequence number which was only enforced in the mempool of unconfirmed transactions. The origi- nal behavior permitted transaction replacement by replacing transactions in the mempool with newer transactions if they have a higher sequence num- ber. Due to transaction replacement rules, it is not enforced due to denial of service attack risks. It appears as though the intended purpose of the sequence number is to replace unbroadcasted transactions. However, this higher sequence number replacement behavior is unenforcible. One cannot be assured that old versions of transactions were replaced in the mempool and a block contains the most recent version of the transaction. A way to enforce transaction versions off-chain is via time commitments.

> 总而言之，比特币系统会将这些带有序列数的交易一直强制放在内存池中，暂时不打包进区块链。如果内存池中有另外一笔交易包含更高的序列数，就用这笔交易替换原先的交易。根据交易替换的规则，由于存在拒绝服务攻击的风险，这不是强制执行的。表面上看，引入序列号的目的是更新未成功广播的交易。但是，这种更高的序列号交易替换行为不是强制的。并不能绝对保证内存池中交易的旧版本一定会被替换，也不能保证区块中一定打包进最新版本的交易。这需要在链下通过时间承诺的方法强制确保最新的交易生效。

A Revocable Transaction spends from a unique output where the transaction has a unique type of output script. This parent’s output has two redemption paths where the first can be redeemed immediately, and the second can only be redeemed if the child has a minimum number of con- firmations between transactions. This is achieved by making the sequence number of the child transaction require a minimum number of confirmations from the parent. In essence, this new sequence number behavior will only permit a spend from this output to be valid if the number of blocks between the output and the redeeming transaction is above a specified block height.

> 一笔可撤销的交易的输入来自于特定唯一输出的一笔交易。这些父交易都有两个输出，其中第一个可以立即被赎回，第二个只能在当前交易得到足够确认数的情况下才能赎回。这是通过使子交易的序列数受父交易的最小确认数约束实现的。实际上，这种新的包含有序列数的交易，只允许输出和赎回交易之间的区块数目超过指定高度时，此输出的花费才有效。

A transaction can be revoked with this sequence number behavior by creating a restriction with some defined number of blocks defined in the sequence number, which will result in the spend being only valid after the parent has entered into the blockchain for some defined number of blocks. This creates a structure whereby the parent transaction with this output becomes a bonded deposit, attesting that there is no revocation. A time period exists which anyone on the blockchain can refute this attestation by broadcasting a spend immediately after the transaction is broadcast.

> 一笔交易可以通过设定一个序列数的方法撤销，创建一笔次包含序列数的交易，当其父交易广播入链后，再经过指定数目的区块确认之后此交易才能生效。这创建了一个结构，其中具有该输出的父交易成为一笔有担保的存款，以证明此交易还没有撤销。锁定时间内，如果有人广播这笔交易想要花费它，其他任何人都能立即检测到这笔支出来反驳这一证明。

If one wishes to permit revocable transactions with a 1000- confirmation delay, the output transaction construction would remain a 2-of-2 multisig:

> 如果一个人希望允许将可撤销的交易延迟确认时间设置为1000个确认，那么如果这是一笔2/2多重签交易的话，输出的构造是这样的：

```
2 <Alice1> <Bob1> 2 OP CHECKMULTISIG
```

However, the child spending transaction would contain a nSequence value of 1000. Since this transaction requires the signature of both coun- terparties to be valid, both parties include the nSequence number of 1000 as part of the signature. Both parties may, at their discretion, agree to create another transaction which supersedes that transaction without any nSequence number.

> 然后，消费它的子交易将包含一个序列数1000。由于此交易需要双方的签名才能生效，所以双方都将序列数1000作为签名的一部分。双方可以根据情况自行决定创建另一笔没有序列数的交易来废弃原先的交易。

This construction, a Revocable Sequence Maturity Contract (RSMC), creates two paths, with very specific contract terms.

> 这个结构，被称作序列到期可撤销合约(RSMC)，它通过非常具体的智能合约，创建了两个花费保证金交易的路径。

The contract terms are:

> 合约条款如下：

1. All parties pay into a contract with an output enforcing this contract

2. Both parties may agree to send funds to some contract, with some waiting period (1000 confirmations in our example script). This is the revocable output balance.

3. One or both parties may elect to not broadcast (enforce) the payouts until some future date; either party may redeem the funds after the waiting period at any time.

4. If neither party has broadcast this transaction (redeemed the funds), they may revoke the above payouts if and only if both parties agree to do so by placing in a new payout term in a superseding transaction pay- out. The new transaction payout can be immediately redeemed after the contract is disclosed to the world (broadcast on the blockchain).

5. In the event that the contract is disclosed and the new payout structure is not redeemed, the prior revoked payout terms may be redeemed by either party (so it is the responsibility of either party to enforce the new terms).

> 1. 双方签订一份合约，该合约有一个输出确保执行

> 2. 双方同意发送一部分资金给合约，这部分资金需要一段时间才能解锁使用(在我们的例子中需要1000个确认)。这部分输出金额是可以撤销的。

> 3. 一方或双方可以暂时不广播支付交易；直到等待期之后，任何一方都可以随时赎回资金。

> 4. 如果双方都没有广播这笔交易(赎回资金)，只有双方同意在替代交易的支出中加入新的合约时，他们才可以撤销上述支出。新的交易支出可以在合约披露(广播入链)后立即赎回。

> 5. 如果合约被披露，新的支付却没有立即被赎回，任何一方都可以赎回之前被撤销的支付条款（因此，任何一方都有责任执行新合约）。

The pre-signed child transaction can be redeemed after the parent transaction has entered into the blockchain with 1000 confirmations, due to the child’s nSequence number on the input spending the parent.

> 在父交易经过1000个确认之后，预签名的子交易输出可以赎回。这是因为子交易输入中的序列数受它所花费的父交易的限制。
In order to revoke this signed child transaction, both parties just agree to create another child transaction with the default field of the nSequence number of MAX INT, which has special behavior permitting spending at any time.

> 为了撤销这笔已经签名的子交易，双方需要协商使用MAX_INT类型的序列数默认字段创建另一笔子交易，该字段具有允许随时花费的特殊行为。

This new signed spend supersedes the revocable spend so long as the new signed spend enters into the blockchain within 1000 confirmations of the parent transaction entering into the blockchain. In effect, if Alice and Bob agree to monitor the blockchain for incorrect broadcast of Commitment Transactions, the moment the transaction gets broadcast, they are able to spend using the superseding transaction immediately. In order to broadcast the revocable spend (deprecated transaction), which spends from the same output as the superseding transaction, they must wait 1000 confirmations. So long as both parties watch the blockchain, the revocable spend will never enter into the transaction if either party prefers the superseding transaction.

> 只要新签名交易的花费在父交易1000个确认时间内广播入链，这笔交易就会取代之前可撤销的承诺交易。实际上，如果Alice和Bob一直在监视区块链，当有人作弊想要广播旧的承诺交易时，他们可以立即广播其替代交易。而作弊者广播的交易需要等待1000个确认，在这之前其资金已经被替代交易花费掉了。所以只要双方都关注区块链，同一时间总有一方更倾向于广播替代交易，那么实际上可撤销的承诺交易永远实际不会进入区块链。

Using this construction, anyone could create a transaction, not broad-
cast the transaction, and then later create incentives to not ever broadcast that transaction in the future via penalties. This permits participants on the Bitcoin network to defer many transactions from ever hitting the blockchain.

> 通过这种结构，任何人都可以仅创建一笔交易而不去立即广播它，这以后通过惩罚来约束人们不去实际广播这笔交易。这使得比特币网络上的参与者可以把许多交易推迟广播入链。

#### 3.3.1 Timestop

#### 3.3.1 减时标识

To mitigate a flood of transactions by a malicious attacker requires a credible threat that the attack will fail.

> 为了减少恶意攻击者发起的大量交易，需要一个可靠的震慑方案来阻止攻击。

Greg Maxwell proposed using a timestop to mitigate a malicious flood on the blockchain:

There are many ways to address this [flood risk] which haven’t been adequately explored yet —for example, the clock can stop when blocks are full; turning the security risk into more hold-up delay in the event of a dos attack.[15]

> Greg Maxwell建议使用一个timestop(减时标识)来缓解区块链上的大量交易洪水攻击：

> 有很多方法可以解决这个[洪水攻击风险]，但这些方法还没有得到充分的探索--例如，可以再区块链写满的时候停止计时，再DDOS攻击事件中，将安全风险用延迟方案来缓解。

This can be mitigated by allowing the miner to specify whether the current (fee paid) mempool is presently being flooded with transactions. They can enter a “1” value into the last bit in the version number of the block header. If the last bit in the block header contains a “1”, then that block will not count towards the relative height maturity for the nSequence value and the block is designated as a congested block. There is an uncongested block height (which is always lower than the normal block height). This block height is used for the nSequence value, which only counts block maturity (confirmations).

> 这可以通过让矿工来判断当前的交易费率下，内存池中是否充斥着大量的交易来缓解。他们可以把区块头版本号的最后一位置为”1”。如果区块头最后一位包含”1”，那么该区块不计入nSequence值的相对高度成熟度，并且指定该区块为拥塞块。同时引入一个指标代表不拥挤的块的块高度(这个值总是低于正常块高度)。这个块高度用于与nSequence值比较，它只用于计算块的成熟度（确认数）。

A miner can elect to define the block as a congested block or not. The default code could automatically set the congested block flag as “1” if the mempool is above some size and the average fee for that set size is above some value. However, a miner has full discretion to change the rules on what automatically sets as a congested block, or can select to permanently set the congestion flag to be permanently on or off. It’s expected that most honest miners would use the default behavior defined in their miner and not organize a 51% attack.

> 矿工可以选择将块定义为拥塞块或不拥塞块，默认代码可以在内存池中支付交易费用的交易超过一定限制后，自动将拥塞块标志为”1”。另外，矿工可以自己定义什么才是一个拥塞块，也可以选择将所有的块都标志位拥塞块或非拥塞块。我们估计诚实的矿工将使用默认定义行为，不会发动51%攻击。

For example, if a parent transaction output is spent by a child with a nSequence value of 10, one must wait 10 confirmations before the transaction becomes valid. However, if the timestop flag has been set, the counting of confirmations stops, even with new blocks. If 6 confirmations have elapsed (4 more are necessary for the transaction to be valid), and the timestop block has been set on the 7th block, that block does not count towards the nSequence requirement of 10 confirmations; the child is still at 6 blocks for the relative confirmation value. Functionally, this will be stored as some kind of auxiliary timestop block height which is used only for tracking the timestop value. When the timestop bit is set, all transactions using an nSe- quence value will stop counting until the timestop bit has been unset. This gives sufficient time and block-space for transactions at the current auxil- iary timestop block height to enter into the blockchain, which can prevent systemic attackers from successfully attacking the system.

> 举例来说，如果一个nSequence值为10的子交易消费了其父交易的输出，就必须等待父交易10个确认后才能生效。但是，如果设置了timestop标识，即使产生新的区块，确认数也可能停止计数。比如经过了6个确认之后(还需要另外4个确认才能让交易有效)，第7个区块设定的timestop标识，那么该区块就不会计入nSequence的计数器。对于子交易来说，相对确认数仍然是6。要实现这些，就需要一个跟踪timestop 标识的区块高度值。当设置了timestop标识时，所有使用nSequence的交易将停止确认数计数，直到下一个没有设置timestop标识的区块入链。这为当前受timestop标识的块影响的交易进入区块链提供了足够的时间和块空间，这可以成功防止攻击者。

However, this requires some kind of flag in the block to designate whether it is a timestop block. For full SPV compatibility (Simple Payment Verification; lightweight clients), it is desirable for this to be within the 80- byte block header instead of in the coinbase. There are two places which may be a good place to put in this flag in the block header: in the block time and in the block version. The block time may not be safe due to the last bits being used as an entropy source for some ASIC miners, therefore a bit may need to be consumed for timestop flags. Another option would be to hardcode timestop activation as a hard consensus rule (e.g. via block size), however this may make things less flexible. By setting sane defaults for timestop rules, these rules can be changed without consensus soft-forks.

> 但是，这需要在块中使用某种标记来指定它是否是timestop区块，还要完全兼容SPV(简单支付验证，轻客户端)，最好设定在区块头的80字节中，而不是coinbase信息里。区块头有两个地方可以很好的放入这个标记：块时间戳或者块版本号。块时间戳可能是不安全的，因为最后一个位空间被一些ASIC矿工用作随机熵源。另一种选择是将timestop激活硬编码为一个严格的一致规则（例如，通过区块大小来区分），但这可能会降低灵活性。要想为timestop设定一个健全的机制，最好可以不需要软分叉就能调整这些规则。

If the block version is used as a flag, the contextual information must match the Chain ID used in some merge-mined coins.

> 如果使用块版本号作为标识，那么在合并挖矿中，上下文信息必须保持一致的Chain ID。


#### 3.3.2 Revocable Commitment Transactions

#### 3.3.2 可撤销的承诺交易

By combining the ascribing of blame as well as the revocable transaction, one is able to determine when a party is not abiding by the terms of the contract, and enforce penalties without trusting the counterparty.

> 把责任归咎和可撤销交易结合起来，就可以确定对方何时不遵守合约，无需互相授信就可以处罚对方。

![Figure4](figures/figure4.png?raw=true "Figure4")

Figure 4: The Funding Transaction F, designated in green, is broadcast on the blockchain after all other transactions are signed. All transactions which only Alice can broadcast are in purple. All transactions which only Bob can broadcast is are blue. Only the Funding Transaction is broadcast on the blockchain at this time.

> 图4:当所有其它交易签署之后，在区块链上广播绿色方框的保证金交易F。所有只有Alice可以广播的交易用紫色框框标识。所有只有Bob可以广播的交易用蓝色框框标识。只有保证金交易才会广播入链。

The intent of creating a new Commitment Transaction is to invalidate all old Commitment Transactions when updating the new balance with a new Commitment Transaction. Invalidation of old transactions can happen by making an output be a Revocable Sequence Maturity Contract (RSMC). To invalidate a transaction, a superseding transaction will be signed and exchanged by both parties that gives all funds to the counterparty in the event an older transaction is incorrectly broadcast. The incorrect broadcast is identified by creating two different Commitment Transactions with the same final balance outputs, however the payment to oneself is encumbered by an RSMC.

> 创建新承诺交易的目的是：当更新交易通道双方余额时，通过使用序列到期可撤销合约(RSMC)，作废旧的承诺交易。为了做到这些，交易双方将签署和交换一笔替代交易，如果旧的承诺交易被错误广播，广播方就会失去所有的资金。这里的两笔承诺交易的输出金额相同，但是返还给自己的输出受RSMC的制约。

In effect, there are two Commitment Transactions from a single Fund- ing Transaction 2-of-2 outputs. Of these two Commitment Transactions, only one can enter into the blockchain. Each party within a channel has one version of this contract. So if this is the first Commitment Transaction pair, Alice’s Commitment Transaction is defined as C1a, and Bob’s Commitment Transaction is defined as C1b. By broadcasting a Commitment Transac- tion, one is requesting for the channel to close out and end. The first two outputs for the Commitment Transaction include a Delivery Transaction (payout) of the present unallocated balance to the channel counterparties. If Alice broadcasts C1a, one of the output is spendable by D1a, which sends funds to Bob. For Bob, C1b is spendable by D1b, which sends funds to Alice. The Delivery Transaction (D1a/D1b) is immediately redeemable and is not encumbered in any way in the event the Commitment Transaction is broadcast.

> 实际上，两笔承诺交易来自于同一笔2/2保证金交易的输出。这两笔承诺交易，最终只有一笔能广播入链。交易通道双方各持有这笔合约交易的一个版本，比如第一对承诺交易，Alice持有的承诺交易定义为C1a，Bob持有的承诺交易定义为C1b。直到有一方请求关闭支付通道时，才会广播C1a或C1b。承诺交易有两个输出，其中一个输出将当前未分配余额支付给通道对手方。如果Alice广播C1a，其中一个输出可由D1a消费，D1a将向Bob发送资金。对于Bob来说，C1b可以被D1b消费，D1b会向Alice发送资金。当承诺交易广播后，支付交易(D1a/D1b)都可以立即赎回。

For each party’s Commitment Transaction, they are attesting that they are broadcasting the most recent Commitment Transaction which they own. Since they are attesting that this is the current balance, the balance paid to the counterparty is assumed to be true, since one has no direct benefit by paying some funds to the counterparty as a penalty.

> 对于当前持有承诺交易的双方，他们会倾向于只广播持有的承诺交易，此交易反映了双方的资金余额，这些支付给对手方的余额是正确的，因为广播另外的承诺交易会损失资金，并不会为自己带来好处。

The balance paid to the person who broadcast the Commitment Transaction, however, is unverified. The participants on the blockchain have no idea if the Commitment Transaction is the most recent or not. If they do not broadcast their most recent version, they will be penalized by taking all the funds in the channel and giving it to the counterparty. Since their own funds are encumbered in their own RSMC, they will only be able to claim their funds after some set number of confirmations after the Commitment Transaction has been included in a block (in our example, 1000 confirmations). If they do broadcast their most recent Commitment Transaction, there should be no revocation transaction superseding the revocable transaction, so they will be able to receive their funds after some set amount of time (1000 confirmations).

> 然而，广播承诺交易的一方收到的资金是未经核实的。参与者并不能通过区块链分辨这是否是最近的承诺交易。由于他们自己的资金锁定在RSMC中，他们只能在承诺交易进入区块链经过指定数目的确认(在我们的示例中，是1000个确认)之后，才能提取资金， 如果广播的承诺交易不是最新版本，他们将会受到惩罚，会失去通道内的资金。如果他们确实广播了最近的承诺交易，那么就不会有人广播撤销交易，他们将能够在一定时间后收到他们的资金（1000个确认）。

By knowing who broadcast the Commitment Transaction and encum- bering one’s own payouts to be locked up for a predefined period of time, both parties will be able to revoke the Commitment Transaction in the fu- ture.

> 通过监视谁广播了承诺交易，并将自己的支付所锁定一段预定的时间，将来双方都可以撤销承诺交易。

#### 3.3.3 Redeeming Funds from the Channel: Cooperative Counterparties 

#### 3.3.3 从支付通道中赎回资金：双方合作

Either party may redeem the funds from the channel. However, the party that broadcasts the Commitment Transaction must wait for the predefined number of confirmations described in the RSMC. The counterparty which did not broadcast the Commitment Transaction may redeem the funds im- mediately.

> 虽然任何一方都可以从该通道赎回资金。然而，广播承诺交易的一方必须等待区块确认数到达RSMC    中描述的预定义确认数才能赎回。没有广播承诺交易的对手方可以即时赎回承诺资金。

For example, if the Funding Transaction is committed with 1 BTC (half to each counterparty) and Bob broadcasts the most recent Commit- ment Transaction, C1b, he must wait 1000 confirmations to receive his 0.5 BTC, while Alice can spend 0.5 BTC. For Alice, this transaction is fully closed if Alice agrees that Bob broadcast the correct Commitment Transac- tion (C1b).

> 例如，如果一笔保证金交易锁定了1BTC(每一方有0.5BTC)，Bob广播了最近的承诺交易C1b，他必须等待1000个确认之后才能赎回属于他的0.5BTC，同时Alice可以立即收到她的0.5BTC。对于Alice来说，如果Alice同意Bob广播的承诺交易C1b是正确的，那支付通道就可以关闭。

![Figure5](figures/figure5.png?raw=true "Figure5")

Figure 5: When Bob broadcasts C1b, Alice can immediately redeem her portion. Bob must wait 1000 confirmations. When the block is immediately broadcast, it is in this  state. Transactions in green are transactions which are committed into the blockchain.

> 图5: 当Bob广播C1b时，Alice可以立即赎回她的的部分，而Bob必须等待1000个确认。当交易广播时，就处于图上这种状况。绿框中代表打包到区块链后立即生效的交易。

After the Commitment Transaction has been in the blockchain for 1000 blocks, Bob can then broadcast the Revocable Delivery transaction. He must wait 1000 blocks to prove he has not revoked this Commitment Transaction (C1b). After 1000 blocks, the Revocable Delivery transaction will be able to be included in a block. If a party attempt to include the Revocable Delivery transaction in a block before 1000 confirmations, the transaction will be invalid up until after 1000 confirmations have passed (at which point it will become valid if the output has not yet been redeemed).

> 承诺交易打包进区块链中经过1000个确认之后，Bob才可以广播赎回交易来收回资金。他必须等待1000个确认来证明自己没有撤销这笔承诺交易(C1b)。在1000个确认之后，承诺交易的赎回部分才能打包进块。如果一方试图在1000个确认之前将可撤销的赎回交易打包入块，那么这笔交易将会失效，一定需要等1000个确认之后，如果此时输出尚未赎回，那么该交易才是有效的。

![Figure6](figures/figure6.png?raw=true "Figure6")

Figure 6:  Alice agrees that Bob broadcast the correct Commitment Transaction and  1000 confirmations have passed. Bob then is able to broadcast the Revocable Delivery (RD1b) transaction on the blockchain.

> 图6： Alice同意Bob广播的承诺交易是正确的。这笔交易也经过了1000个确认，此时Bob可以在区块链上广播可撤销赎回交易(RD1b)


After Bob broadcasts the Revocable Delivery transaction, the channel is fully closed for both Alice and Bob, everyone has received the funds which they both agree are the current balance they each own in the channel.

> 当Bob广播可撤销赎回交易时，他与Alice之间的支付通道完全关闭，每个人都收回了他们协商一致的资金，这些资金是他们各自在支付通道中拥有的当前余额。

If it was instead Alice who broadcast the Commitment Transaction (C1a), she is the one who must wait 1000 confirmations instead of Bob.

> 如果广播承诺交易(C1a)的是Alice，那么她必须等待1000个确认，而不是Bob。

#### 3.3.4 Creating a new Commitment Transaction and Revoking Prior Commitments 

#### 3.3.4 创建新的承诺交易并撤销之前的承诺交易

While each party may close out the most recent Commitment Transaction at any time, they may also elect to create a new Commitment Transaction and invalidate the old one.
Suppose Alice and Bob now want to update their current balances from 0.5 BTC each refunded to 0.6 BTC for Bob and 0.4 BTC for Alice.

When they both agree to do so, they generate a new pair of Commitment Transactions.

![Figure7](figures/figure7.png?raw=true "Figure7")

Figure 7: Four possible transactions can exist, a pair with the old commitments, and another pair with the new commitments. Each party inside the channel can only broadcast half of the total commitments (two each). There is no explicit enforcement preventing any particular Commitment being broadcast other than penalty spends, as they are all valid unbroadcasted spends.  The Revocable Commitment  still exists with the C1a/C1b pair,  but are not displayed for brevity.
