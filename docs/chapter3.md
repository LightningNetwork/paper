## 3.Bidirectional Payment Channels
## 3. 双向支付通道

Micropayment channels permit a simple defdeerral of a transaction state to be broadcast at a later time. The contracts are enforced by creating a responsibility for one party to broadcast transactions before or after certain dates. If the blockchain is a decentralized timestamping system, it is possible to use clocks as a component of decentralized consensus[5] to determine data validity, as well as present states as a method to order events[6].

> 微支付通道允许将一笔交易简单的延迟到以后广播。这些合约的执行方式是：让一方必须在特定日期之前或之后广播交易。如果区块链是一个去中心化的时间戳系统，那么可以使用时间戳作为去中心化共识的一个部分来确定数据的有效性，这相当于解决了当前状态的时序同步问题[6]。

By creating timeframes where certain states can be broadcast and later invalidated, it is possible to create complex contracts using bitcoin transaction scripts. There has been prior work for Hub-and-Spoke Micro- payment Channels[7][8][9] (and trusted payment channel networks[10][11]) looking at building a hub-and-spoke network today. However, Lightning Network’s bidirectional micropayment channel requires the malleability soft- fork described in Appendix A to enable near-infinite scalability while miti- gating risks of intermediate node default.

> 当前的交易状态下，这些交易可以被立即广播，或等待失效，通过为这个特定状态创建时间快照，就能利用比特币的交易脚本构建复杂的智能合约。此前，中心辐射型的微支付通道[7][8][9](以及可信支付通道[10][11])已经考虑了如何在今天构建一个中心辐射性微支付通道网络。但是，闪电网络的双向微支付通道需要比特币系统采取软分叉先解决附录中所描述的交易延展性问题，才能实现近乎无限的可扩展性，同时也能控制中间节点的出错风险。

By chaining together multiple micropayment channels, it is possible to create a network of transaction paths. Paths can be routed using a BGP- like system, and the sender may designate a particular path to the recipient. The output scripts are encumbered by a hash, which is generated by the recipient. By disclosing the input to that hash, the recipient’s counterparty will be able to pull funds along the route.

> 通过将多个微支付通道链接在一起，就有可能创建一个交易路径网络。路径可以使用类似BGP的协议进行路由，发送方可以指定特定的路径发送交易给接收方。输出脚本由接收方生成的散列来验证。通过提供散列的原像，接收方的交易对手就能够沿着这条路径传递资金。

### 3.1 The Problem of Blame in Channel Creation
### 3.1 通道创建中的责任问题

In order to participate in this payment network, one must create a micro- payment channel with another participant on this network.

> 为了参与到这个支付网络中来，一个人必须与这个网络上的另一个参与者创建一个微支付通道。

#### 3.1.1 Creating an Unsigned Funding Transaction
#### 3.1.1 创建一个未签署的保证金交易

An initial channel Funding Transaction is created whereby one or both chan- nel counterparties fund the inputs of this transaction. Both parties create the inputs and outputs for this transaction but do not sign the transaction.

> 最初的通道保证金交易需要交易的一方或交易双方为该交易的输入提供资金。双方参与创建这笔交易的输入和输出，但是先不对交易签名。

The output for this Funding Transaction is a single 2-of-2 multisigna-
ture script with both participants in this channel, henceforth named Alice and Bob. Both participants do not exchange signatures for the Funding Transaction until they have created spends from this 2-of-2 output refund- ing the original amount back to its respective funders. The purpose of not signing the transaction allows for one to spend from a transaction which does not yet exist. If Alice and Bob exchange the signatures from the Fund- ing Transaction without being able to broadcast spends from the Funding Transaction, the funds may be locked up forever if Alice and Bob do not cooperate (or other coin loss may occur through hostage scenarios whereby one pays for the cooperation from the counterparty).

> 这笔交易的输出是一个2/2多重签名地址，需要这个通道的双方参与者都同意才能花费这笔输出。我们按照惯例将通道两端的参与者命名为Alice和Bob。此时双方还不会为保证金交易交换签名，他们要先创建两笔花费，能够从保证金交易中将原始金额返还双方。不签署交易的目的是允许人们消费一个还不存在的交易。如果Alice和Bob在交换其签名之前广播保证金交易，此时一方不合作的话，这笔钱就可能被永久锁定(或者由一方承担了合作失败的损失)。

Alice and Bob both exchange inputs to fund the Funding Transaction(to know which inputs are used to determine the total value of the channel), and exchange one key to use to sign with later. This key is used for the 2-of-2 output for the Funding Transaction; both signatures are needed to spend from the Funding Transaction, in other words, both Alice and Bob need to agree to spend from the Funding Transaction.

> Alice和Bob互相交换保证金交易的输入(为了确定哪些输入用于确定通道的总容量)，然后交换一个密钥以供以后签名使用。这个密钥用于消费2/2保证金交易的输出，换句话说，如果要花费这笔保证金，需要Alice和Bob双方都同意。

#### 3.1.2 Spending from an Unsigned Transaction
#### 3.1.2 消费一笔未签名的交易

The Lightning Network uses a SIGHASH NOINPUT  transaction  to  spend from this 2-of-2 Funding Transaction output, as it is necessary to spend from a transaction for which the signatures are not yet exchanged. SIGHASH NOINPUT, implemented using a soft-fork, ensures transactions can be spent from before it is signed by all parties, as transactions would need to be signed to get a transaction ID without new sighash flags. Without SIGHASH NOINPUT, Bitcoin transactions cannot be spent from before they may be broadcast —it’s as if one could not draft a contract without paying the other party first. SIGHASH NOINPUT resolves this problem. See Appendix A for more information and implementation.

> 闪电网络使用 SIGHASH NOINPUT类型的交易来花费2/2保证金交易的输出，因为必须要构建一笔交易用于花费尚未交换签名的交易输出。SIGHASH NOINPUT将使用软分叉实现，它确保了交易可以在双方签署之前就能构造花费的交易，如果没有这个操作符的话，那交易就必须通过签署才能构造交易ID，那样就不能在广播这笔交易之前先来构造消费它的交易--这就好像一个人不先付款给另一方就不能起草合同一样。SIGHASH NOINPUT解决了这个问题，有关这方面更多信息和实现，亲参考附录A。

Without SIGHASH NOINPUT, it is not possible to generate a spend from a transaction without exchanging signatures, since spending the Fund- ing Transaction requires a transaction ID as part of the signature in the child’s input. A component of the Transaction ID is the parent’s (Funding Transaction’s) signature, so both parties need to exchange their signatures of the parent transaction before the child can be spent. Since one or both par- ties must know the parent’s signatures to spend from it, that means one or both parties are able to broadcast the parent (Funding Transaction) before the child even exists. SIGHASH NOINPUT gets around this by permitting the child to spend without signing the input. With SIGHASH NOINPUT, the order of operations are to:

> 如果没有SIGHASH NOINPUT，就无法在不交换签名的情况下生成花费它的交易，因为要花费保证金交易的输出，就需要交易ID作为花费交易输入的一部分。交易ID的一个组成部分是它的父交易方(即保证金交易)的签名，因此双方需要在创建子交易之前交换父交易的签名。由于一方或双方都需要夫交易的签名才能花费它，这就意味着一方或双方都能在子交易存在之前就能广播父交易(保证金交易)。SIGHASH NOINPUT允许子交易在不签署交易输入的情况下花费它，从而解决了这个问题。使用SIGHASH NOINPUT，操作顺序为：

1.Create the parent (Funding Transaction)

2.Create the children (Commitment Transactions and all spends from the commitment transactions)

3.Sign the children

4.Exchange the signatures for the children

5.Sign the parent

6.Exchange the signatures for the parent

7.Broadcast the parent on the blockchain

> 1.创建父交易(保证金交易)

> 2.创建子交易(承诺交易以及所有相关的承诺交易的花费)

> 3.为子交易签名

> 4.双方交换子交易的签名

> 5.为父交易签名

> 6.双方交换父交易的签名

> 7.在区块链上广播父交易

One is not able to broadcast the parent (Step 7) until Step 6 is com- plete. Both parties have not given their signature to spend from the Funding Transaction until step 6. Further, if one party fails during Step 6, the parent can either be spent to become the parent transaction or the inputs to the parent transaction can be double-spent (so that this entire transaction path is invalidated).

> 在第6步完成之前，不能广播父交易(步骤7)。在第6步之前，双方都没有签名同意花费保证金交易。此外，如果在第6步中，有一方作弊，即父交易被花费了，或者父交易的输入被双重支付，整个交易路径就都被认为是无效的。

#### 3.1.3 Commitment  Transactions:  Unenforcible Construction
#### 3.1.3 承诺交易: 不能强制履行

After the unsigned (and unbroadcasted) Funding Transaction has been cre- ated, both parties sign and exchange an initial Commitment Transaction. These Commitment Transactions spends from the 2-of-2 output of the Fund- ing Transaction (parent). However, only the Funding Transaction is broad- cast on the blockchain.

> 当还没有签名(且没有广播)的保证金交易创建完成之后，双方将签署并交换初始承诺交易。这些承诺交易花费的是2/2保证金交易的输出。值得注意的是，只有保证金交易才会广播上链。

Since the Funding Transaction has already entered into the blockchain, and the output is a 2-of-2 multisignature transaction which requires the agreement of both parties to spend from, Commitment Trans- actions are used to express the present balance. If only one 2-of-2 signed Commitment Transaction is exchanged between both parties, then both parties will be sure that they are able to get their money back after the Funding Transaction enters the blockchain. Both parties do not broadcast the Commitment Transactions onto the blockchain until they want to close out the current balance in the channel. They do so by broadcasting the present Commitment Transaction.

> 由于保证金交易已经广播入链，并且输出是一个2/2多重签名交易，这需要双方均同意才能花费，因此可以采用承诺交易来确认当前状态下双方的余额。如果双方之间只交换一笔2/2签名的承诺交易，而通过这笔交易，双方能确保在保证金交易广播入链后仍然能够取回资金。那么双方就不需要将承诺交易广播入链，除非他们希望关闭通道并结算余额。也只有这时候才需要广播承诺交易。

Commitment Transactions pay out the respective current balances to each party. A naive (broken) implementation would construct an unbroad- casted transaction whereby there is a 2-of-2 spend from a single transaction which have two outputs that return all current balances to both channel counterparties. This will return all funds to the original party when creat- ing an initial Commitment Transaction.

> 承诺交易会向每一方支付各自的流动余额。一个简单(不完整)的方法就是构建一笔交易，该交易花费2/2多重签名保证金交易的输入，有两个输出，就是将当前通道的余额返回给通道双方。通过创建这笔初始承诺交易，将会把通道资金的原始余额返回给双方。

![Figure1](figures/figure1.png?raw=true "Figure1")

Figure 1: A naive broken funding transaction is described in this diagram. The Funding Transaction (F), designated in green, is broadcast on the blockchain after all other trans- actions are signed. All other transactions spending from the funding transactions are not yet broadcast, in case the counterparties wish to update their balance. Only the Funding Transaction is broadcast on the blockchain at this time.

> 图一：图1描述了一个简单的分配保证金交易的方法。绿色的部分代表保证金交易(F)，当其他交易都签署之后才在区块链上广播，以防交易对手更新他们的通道余额。此场景中只有保证金交易才会被广播。

For instance, if Alice and Bob agree to create a Funding Transac- tion with a single 2-of-2 output worth 1.0 BTC (with 0.5 BTC contribution from each), they create a Commitment Transaction where there are two 0.5 BTC outputs for Alice and Bob. The Commitment Transactions are signed first and keys are exchanged so either is able to broadcast the Commitment Transaction at any time contingent upon the Funding Transaction enter- ing into the blockchain. At this point, the Funding Transaction signatures can safely be exchanged, as either party is able to redeem their funds by broadcasting the Commitment Transaction.

> 例如，如果Alice和Bob同意创建一笔包含1.0BTC(每一方存入0.5BTC)的2/2多重签名保证金交易，他们就需要创建一笔承诺交易，保证返还给Alice和Bob各自0.5BTC。双方首先对这笔承诺交易交换签名，这样在保证金交易广播入链后，任何一方都可以在任何时候广播这笔承诺交易。此时，可以放心的签署保证金交易，因为任何一方都可以通过广播承诺交易来赎回资金。

This construction breaks, however, when one wishes to update the present balance. In order to update the balance, they must update their Commitment Transaction output values (the Funding Transaction has al- ready entered into the blockchain and cannot be changed).

> 然而，当一方想要改变其当前通道内的余额时，这种结构就被打破了。为了更新余额，他们就必须更新他们的承诺交易的输出值(而保证金交易已经广播入链，不能更改了)。

When both parties agree to a new Commitment Transaction and ex- change signatures for the new Commitment Transaction, either Commit- ment Transactions can be broadcast. As the output from the Funding Transaction can only be redeemed once, only one of those transactions will be valid. For instance, if Alice and Bob agree that the balance of the channel
is now 0.4 to Alice and 0.6 to Bob, and a new Commitment Transaction is created to reflect that, either Commitment Transaction can be broadcast. In effect, one would be unable to restrict which Commitment Transaction is broadcast, since both parties have signed and exchanged the signatures for either balance to be broadcast.

> 当双方都同意新的承诺交易并为其交换签名的时候，任一提交的交易都可以被广播。由于保证金交易的输出只能花费一次，因此这些交易中只有一个是有效的。例如，如果Alice和Bob同意当前支付通道的余额分配是Alice拥有0.4BTC，Bob拥有0.6BTC，就需要创建一笔新的承诺交易来反映当前情况。此时之前的承诺交易也有可能被广播。实际上，当前无法限制广播哪个承诺交易，因为双方都已经交换的签名，任何一种余额分配的承诺交易都是可以广播的。


![Figure2](figures/figure2.png?raw=true "Figure2")

Figure 2: Either of the Commitment Transactions can be broadcast any any time by either party, only one will successfully spend from the single Funding Transaction. This cannot work because one party will not want to broadcast the most recent transaction.

> 图2：任何一方都可以在任何时间广播任何一笔承诺交易，当然，只有一笔是最终有效的。因为可能有一方并不希望广播最近的交易，却又无法限制这种情况，所以此方案存在缺陷。

Since either party may broadcast the Commitment Transaction at any time, the result would be after the new Commitment Transaction is gener- ated, the one who receives less funds has significant incentive to broadcast the transaction which has greater values for themselves in the Commitment Transaction outputs. As a result, the channel would be immediately closed and funds stolen. Therefore, one cannot create payment channels under this model.

> 由于任何一方都可以再任何时间广播承诺交易，那么在生成新的承诺交易后，持有较少资金的一方有显著的动机广播对自身输出金额更大的承诺交易。结果，该通道将立即关闭，资金将被窃取，因此，这种模式是无法安全的建立支付通道的。


#### 3.1.4 Commitment Transactions: Ascribing Blame
#### 3.1.4 承诺交易：归咎责任

Since any signed Commitment Transaction may be broadcast on the blockchain,  and only one can be successfully broadcast,  it is necessary   to prevent old Commitment Transactions from being broadcast.   It is   not possible to revoke tens of thousands of transactions in Bitcoin, so an alternate method is necessary. Instead of active revocation enforced by the blockchain, it’s necessary to construct the channel itself in similar manner to a Fidelity Bond, whereby both parties make commitments, and violations of these commitments are enforced by penalties. If one party violates their agreement, then they will lose all the money in the channel.

> 由于任何已签署的承诺交易都可以在区块链上广播，并且只能成功广播其中一笔交易，因此有必要防止旧的承诺交易被广播。但同时撤销数万笔比特币交易时不可能的，因此有必要采用另一种方法。与区块链强制执行的主动撤销不同，应该以类似于忠诚契约的方式来构造通道本身，双方据此作出承诺，当违反这些承诺时将会受到惩罚。如果一方违反了协议，他将失去通道中所有的资金。

For this payment channel, the contract terms are that both parties commit to broadcasting only the most recent transaction. Any broadcast of older transactions will cause a violation of the contract, and all funds are given to the other party as a penalty.

> 这种支付通道遵循这样的合同条款：双方承诺只广播最近的交易。任何旧交易的广播都将违反合同，所有的资金都将作为罚款给予另一方。

This can only be enforced if one is able to ascribe blame for broad- casting an old transaction. In order to do so, one must be able to uniquely identify who broadcast an older transaction. This can be done if each coun- terparty has a uniquely identifiable Commitment Transaction. Both parties must sign the inputs to the Commitment Transaction which the other party is responsible for broadcasting. Since one has a version of the Commitment Transaction that is signed by the other party, one can only broadcast one’s own version of the Commitment Transaction.

> 只有当一方可以对广播旧交易的另一方施以惩罚时，这一机制才能生效。为了做到这一点，必须能唯一的标识谁广播了较早的承诺交易。这需要每一方都有一笔唯一并可标识的承诺交易。双方必须签署对方负责广播的承诺交易的输入。如果一方拥有对方签署的承诺交易，他就可以放心广播自己所创建的承诺交易。

For the Lightning Network, all spends from the Funding Transaction output, Commitment Transactions, have two half-signed transactions. One Commitment Transaction in which Alice signs and gives to Bob (C1b), and another which Bob signs and gives to Alice (C1a). These two Commitment Transactions spend from the same output (Funding Transaction), and have different contents; only one can be broadcast on the blockchain, as both pairs of Commitment Transactions spend from the same Funding Transac- tion. Either party may broadcast their received Commitment Transaction by signing their version and including the counterparty’s signature. For ex- ample, Bob can broadcast Commitment C1b, since he has already received the signature for C1b from Alice —he includes Alice’s signature and signs C1b himself. The transaction will be a valid spend from the Funding Trans- action’s 2-of-2 output requiring both Alice and Bob’s signature.

> 对于闪电网络，所有的来自于保证金交易的输出的花费，即承诺交易们，都只有一半签名。其中 Alice对一笔承诺交易签名并发给Bob(C1b)，Bob对另一笔承诺交易并发给Alice(C1a)。这两笔承诺交易的输入来自于同一笔(保证金)交易，但是内容不同；这两笔交易只有一笔可以在区块链上广播。任何一方都可以收到包含对方签名的承诺交易，然后加上自己的签名进行广播。例如，Bob可以广播承诺交易C1b，因为他已经从Alice那里收到了C1b的签名--他只需要再对C1b自己签署一遍就可以了。这笔交易将是保证金交易2/2输出的有效花费，因为同时包含了Alice和Bob的签名。

