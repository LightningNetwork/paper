# 6 Lightning Pool: A Channel Liquidity Market- place as a Shadow Chain

In this section, we build upon the prior sections outlining the abstract Channel Lease Marketplace deﬁnition, as well as shadowchain operation, and construct our Lightning Pool implementation at a low-level. We ﬁrst begin by detailing our implementation of the CLM algorithms, as well as our choice of certain free parameters. With this concrete structure in place, we’ll then go up a layer of ab- straction to demonstrate how Lightning Pool can be operated as a shadowchain on Bitcoin today, without any further modiﬁcations enhancements.

## 6.1 Instantiating a CLM

### 6.1.1 System Initialization

#### Batch Key Parameter

Before an instance of Lightning Pool can be used by willing agents, the system must ﬁrst be initialized. This operation can be performed only by the Orchestrator of the auctioneer. Within the system, we’ll utilize an incremented Elliptic Curve point which we refer to as the batchID for several operations. The batchID serves to uniquely identiﬁed a given batch, and is incremented after each successful batch.

The batchID itself is a nothing up my sleeve (NUMS) point which has been generated in a manner that no one, not even the auctioneer knows the discrete log to. The raw serialized batchID (for the very ﬁrst batch) within the Lightning Pool system can be expressed in the following syntax (displayed using hex-encoding of a compressed key encoding of the batch key itself):

```
Bk = NUMSgen(1λ)
```

Let the current batchID for the nth batch be Bk . Let G be a cyclic group of order prime order p, generated by an element G. We now deﬁne two helper functions to allow us to ”seek” round the batchID key-space:

![Figure6_1_1](figures/figure6_1_1.png?raw=true "Figure6_1_1")

With the system initializtion , we’ll now move onto specifying the structure of a Marketplace Account within Lightning Pool.

#### Auctioneer State Initialization

Now that we have deﬁned the set of initialization and manipulation methods for our batch key parameter, we’ll move onto the initialization of the remaining system. In order to prevent key-reuse across the entire system, we employ a similar key-derivation scheme to that of the Lightning Network’s current com- mitment transaction format [21]. This key derivation will be used within all account scripts within the system, as well as the auctioneer’s main account.

First, we deﬁne a helper function for deriving the auctioneer’s current key Apkm    from  the  static  auctioneer  account  keyApk  parameterized  by  the  current batchID. As noted above, the batchID serves as both a public key within the system as well as a counter. The batchID may be expressed as a normal com- pressed public key, or as an integer Nb which denotes the scalar multiple oﬀ-set from the starting batch key Bk0 : [Bk0 ]Nb. We deﬁne the auctioneerScript as follows:

![Figure6_1_1_2](figures/figure6_1_1_2.png?raw=true "Figure6_1_1_2")

The script itself is a simple script that simply veriﬁes a proper auctioneer signature given a particular batchID. In order to make all scripts uniform (as the account scripts are P2WSH outputs, we wrap this script in a P2WSH layer of indi- rection as well. With this algorithm deﬁned, we can now deﬁne the SystemInit implementation for Lightning Pool that derives the ﬁrst batch key along with the starting script of the auctioneer.)

![Figure6_1_1_3](figures/figure6_1_1_3.png?raw=true "Figure6_1_1_3")


Once the third return value, auctioneer’s master account has been conﬁrmed. Participants are able to open accounts, submit orders, and ﬁnally participate in auction batches.

### 6.1.2 Lightning Pool Accounts

Next, we move onto the Marketplace Account structure for agents within the Lightning Pool marketplace itself. Similar to the auctioneer’s master account, we apply a key derivation scheme that combines the auctioneer’s key, the batch key, a key supplied by the trader, and a distinct trader speciﬁc secret to ensure, that:

❼ A P2WSH output script is never re-used.

❼ Traders rotate keys with each batch.

❼ The set of trader keys using within a batch itself is indistinguishable w.r.t the input keys referenced and newly created outputs keys.

Let Pt be a trader’s base key, St ．$ Z2N be an account-speciﬁc secret gener- ated by the trader, and PA be the auctioneer’s long-term public key.We deﬁne a new algorithm traderAccountScript which will be used to derive the pkScript for a given trader:

![Figure6_1_2](figures/figure6_1_2.png?raw=true "Figure6_1_2")

The above script can either be spent via the time out clause using the follow- ing witness stack, using nil value passes an empty signature to force execution of the timeout clause.
nil traderSig witnessScript Or via the normal spend path way which will be used to authorized batches, account closing, and any other account modiﬁcations:

#### auctioneerSig traderSig witnessScript

Note that each trader starts using the current batch key at the time they joined the marketplace. However, as we’ll see below in the execution section, a trader’s key gets rotated with each batch they participate in, meaning that the set of batch keys used within a trader’s account output script will eventually become de-synchronized across the market unless all trader’s participate in all batches, which is unlikely.

Given the traderAccountScript algorithm, we’ll now deﬁne our implemen- tation of the set of Account Operations methods:

![Figure6_1_2_2](figures/figure6_1_2_2.png?raw=true "Figure6_1_2_2")

Notice how the batchKey is incremented for all account modiﬁcation oper- ations. In this manner, the batchKey also serves as a sequence number within the scripts to ensure that no scripts are re-used within the system.

Users are able to recover their accounts themselves if data has been lost by scanning the chain for the above instances of newAcctScript and utilizing the timeout clause within the account script of a trader’s account.

### 6.1.3 Channel Leases in the Lightning Network

Now that we have our concrete account structure, we’ll move on to presenting a concrete instantiation of a Channel Lease based on today’s widely used payment channel implementation within Lightning Network.

#### Channel Lease Duration Enforcement

The unique component that sets apart a regular channel from one that was created via a channel lease contract is duration enforcement. As a channel lease contracts states the capital must be committed to the network for a minimum period of time, in order to implement this in a trust-minimized manner, we must enhance the existing channel format [21] used in the Lightning Network today. Our tool of choice for creating minimum duration enforced channels is the OP CHECKLOCKTIMEVERIFY [29] op-code. Our construction is similar to the one proposed in [30] Minimally, we need to enforce the following conditions:

❼ The Liquidity Maker involved in a channel lease cannot sweep the funds in their settled commitment output as manifested on their commitment or the commitment of the remote party until Dblock Bitcoin blocks has passed since the creation of the channel lease.

❼ The Liquidity Maker also cannot fully sweep any funds that are sus- pended within HTLC outputs until Dblock Bitcoin blocks has passed.

The second item is of great importance to ensure that the seller of a channel lease can’t just move all the committed funds into HTLCs, then close the chan- nel and be fully refunded, netting the lease premium in the process. Instead, we need to ensure that the node is able to resolve any HTLCs on-chain if needed, while still being forced to commit the funds in ancestors of the multi-sig funding output, until the lease duration has expired.


We now make a small modiﬁcation ﬁrst to the settled local output of the Liquidity Maker:

```
OP_IF
    <revoke key>
OP_ELSE
    <lease duration in blocks> OP_CHECKLOCKTIMEVERIFY OP_DROP
    <delay in blocks> OP_CHECKSEQUENCEVERIFY OP_DROP <delay key>
OP_ENDIF

OP_CHECKSIG
```

Next, we make a similar modiﬁcation to the settled remote output of the Liquidity Maker, assuming anchor output based channels [4] are used:

```
<localKey> OP_CHECKSIGVERIFY
<lease duration> OP_CHECKLOCKTIMEVERIFY
1 OP_CHECKSEQUENCEVERIFY
```

Finally, we modify the oﬀered HTLC outputs of the Liquidity Maker for their local commitment transaction:

```
OP_IF
    <revoke key>
OP_ELSE
    <lease duration in blocks> OP_CHECKLOCKTIMEVERIFY OP_DROP
    <delay in blocks> OP_CHECKSEQUENCEVERIFY OP_DROP
    <delay key>
OP_ENDIF

OP_CHECKSIG
```
A less trust-minimized version of channel lease duration enforcement is possi- ble simply by having the Liquidity Taker refuse a cooperative channel closure until the lease duration has expired. With this non-script based enforcement, the only direct option the Liquidity Maker has is to force-close their channel. However, the operator of an auction venue can request additional information along-side orders before batch execution (as detailed below) to identify prema- ture force closes on-chain in order to penalize the renegading party.

#### Channel Lease Funding Protocol

Given the existence of a new modiﬁed channel CL that supports the channel lease protocol, we require a new way to fund the channels as a channel lease itself will partially-bind the following parameters of a given channel:

❼ The size of the channel itself.

❼ The two multi-sig scripts used within the channel.

❼ The duration of the channel lease itself.

Rather than modifying the base funding protocol of the Lightning Network, we’ve opted to instead provide a new ”side-loadable” partial funding binding API we call a channel shim [26]. A channel shim allows a party A to expect certain parameters of the channel itself. Given the pendingChanID which is used to identify an unﬁnalized channel within the Lightinng Network [19], an algorithm

RegisterChannelShim(Γ, Pa, outPoint) instructs a Lightning Node to use a prearranged public key as speciﬁed within channel lease Γ for its portion of the multi-sig output used within the ultimate channel.

The existence of the channel shim API allows a node to proceed in the set up of a channel for which it may not yet know the full  funding transaction   to. Given the lease, and the expected outpoint, both sides can fully sign the commitment transaction in a manner that doesn’t incur any risk as due to the account structure, they’ll need to sign oﬀ on the batch funding transaction itself before it can be broadcast.

The funding ﬂow using this new order shim, assuming that match making and market clearing has already occurred, resembles the following ﬂow, with Alice being the Liquidity Taker and Bob being the Liquidity Maker:

![Figure6_1_3](figures/figure6_1_3.png?raw=true "Figure6_1_3")


In this modiﬁed ﬂow, notice that the taker returns the pre-generated public key to use within the multi-sig within the AcceptChannel method, and the taker uses the canned leasePoint as the input to the funding transaction. As we’ll see below the leasePoint itself is generated after market clearing, and during the construction of the batch execution transaction. The leasePoint as it exists on the batch execution transaction creates a new channel point that satisﬁes the details of the negotiated channel lease Γ: the amount of the lease, and the pkScript of the two multi-sig keys Pa and Pb.

We note that the channel shim abstraction has a number of independent uses including strong layer isolation for more elaborate multi-party channel protocols. Notice how the base BOLT funding ﬂow is unmodiﬁed, meaning that a higher level application can handle the speciﬁed details of the multi-party transaction protocol, while the unmodiﬁed Lightning node software manages the underlying channel itself.

